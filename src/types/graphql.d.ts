export type Maybe<T> = T | null
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string
  String: string
  Boolean: boolean
  Int: number
  Float: number
  /** An ISO 8601-encoded datetime */
  DateTime: any
  Blob: any
  /** Represents non-fractional signed whole numeric values. Since the value may exceed the size of a 32-bit integer, it's encoded as a string. */
  BigInt: any
}

/** Personal access tokens */
export type AccessToken = Node & {
  __typename?: 'AccessToken'
  createdAt: Scalars['DateTime']
  description: Scalars['String']
  descriptionHtml: Scalars['String']
  id: Scalars['ID']
  /** It returns true if (1) the access token is not revoked, and (2) the author of the access token is alive. */
  isActive: Scalars['Boolean']
  isRevoked: Scalars['Boolean']
  lastUsedAt?: Maybe<Scalars['DateTime']>
  scopes: Array<AccessTokenScope>
  title: Scalars['String']
  /** The secret token value, which is only available via `createAccessToken` mutation. */
  token?: Maybe<Scalars['String']>
  updatedAt: Scalars['DateTime']
  /** The author of the access token */
  user: User
}

/** The connection type for AccessToken. */
export type AccessTokenConnection = {
  __typename?: 'AccessTokenConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AccessTokenEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AccessToken>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']
}

/** An edge in a connection. */
export type AccessTokenEdge = {
  __typename?: 'AccessTokenEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']
  /** The item at the end of the edge. */
  node?: Maybe<AccessToken>
}

export enum AccessTokenScope {
  Administer = 'ADMINISTER',
  Read = 'READ',
  Write = 'WRITE',
}

/** Autogenerated input type of ArchiveFolder */
export type ArchiveFolderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['ID']
}

/** Autogenerated return type of ArchiveFolder */
export type ArchiveFolderPayload = {
  __typename?: 'ArchiveFolderPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  folder: Folder
}

/** Autogenerated input type of ArchiveGroup */
export type ArchiveGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  groupId: Scalars['ID']
}

/** Autogenerated return type of ArchiveGroup */
export type ArchiveGroupPayload = {
  __typename?: 'ArchiveGroupPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  group: Group
}

export type Attachment = Node & {
  __typename?: 'Attachment'
  author: User
  createdAt: Scalars['DateTime']
  /** The data of the attachment in binary. Prefer `data_url` if you use JSON for serializers */
  data: Scalars['Blob']
  /** The same value as `data` but encoded in data URL schema */
  dataUrl: Scalars['String']
  id: Scalars['ID']
  key: Scalars['String']
  kind: AttachmentKind
  /** A MIME type detected from its data and name */
  mimeType: Scalars['String']
  name: Scalars['String']
  path: Scalars['String']
  /** The file size */
  size: Scalars['Int']
  url: Scalars['String']
}

/** How and where the attachment is used. */
export enum AttachmentKind {
  General = 'GENERAL',
  GroupCoverImage = 'GROUP_COVER_IMAGE',
  UserAvatarImage = 'USER_AVATAR_IMAGE',
  UserCoverImage = 'USER_COVER_IMAGE',
}

/** Kibela Web API budget like RateLimit of RESTful API */
export type Budget = {
  __typename?: 'Budget'
  consumed: Scalars['BigInt']
  /** The point cost for the current query counting against the budget. */
  cost: Scalars['BigInt']
  remaining: Scalars['BigInt']
}

/** Autogenerated input type of CloseAnnouncement */
export type CloseAnnouncementInput = {
  announcementKey: Scalars['String']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated return type of CloseAnnouncement */
export type CloseAnnouncementPayload = {
  __typename?: 'CloseAnnouncementPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** A comment that belongs to a Note */
export type Comment = Node & {
  __typename?: 'Comment'
  anchor: Scalars['String']
  author: User
  content: Scalars['String']
  contentHtml: Scalars['String']
  contentSummaryHtml: Scalars['String']
  contentUpdatedAt: Scalars['DateTime']
  contributors: UserConnection
  createdAt: Scalars['DateTime']
  editedAt?: Maybe<Scalars['DateTime']>
  id: Scalars['ID']
  isLikedByCurrentUser: Scalars['Boolean']
  likers: UserConnection
  path: Scalars['String']
  publishedAt?: Maybe<Scalars['DateTime']>
  updatedAt: Scalars['DateTime']
}

/** A comment that belongs to a Note */
export type CommentContributorsArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  orderBy?: Maybe<ContributorOrder>
}

/** A comment that belongs to a Note */
export type CommentLikersArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
}

/** The connection type for Comment. */
export type CommentConnection = {
  __typename?: 'CommentConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CommentEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Comment>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']
}

/** An edge in a connection. */
export type CommentEdge = {
  __typename?: 'CommentEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']
  /** The item at the end of the edge. */
  node?: Maybe<Comment>
}

export type ContributorOrder = {
  direction?: Maybe<OrderDirection>
  field?: Maybe<ContributorOrderField>
}

/** Properties by which contributors can be ordered. */
export enum ContributorOrderField {
  ContributedAt = 'CONTRIBUTED_AT',
}

/** Autogenerated input type of CreateAccessToken */
export type CreateAccessTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  description: Scalars['String']
  scopes: Array<AccessTokenScope>
  title: Scalars['String']
}

/** Autogenerated return type of CreateAccessToken */
export type CreateAccessTokenPayload = {
  __typename?: 'CreateAccessTokenPayload'
  /** It includes the secret `token`, which you never see again. */
  accessToken: AccessToken
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated input type of CreateComment */
export type CreateCommentInput = {
  /** The default author is the current user, but you can set any user as the author on importing comments */
  authorId?: Maybe<Scalars['ID']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  commentableId: Scalars['ID']
  content: Scalars['String']
  /** The time when the comment is published. If not specified, `createdAt` is set to `publishedAt` */
  publishedAt?: Maybe<Scalars['DateTime']>
}

/** Autogenerated return type of CreateComment */
export type CreateCommentPayload = {
  __typename?: 'CreateCommentPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  comment: Comment
}

/** Autogenerated input type of CreateFolderPin */
export type CreateFolderPinInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  noteId: Scalars['ID']
}

/** Autogenerated return type of CreateFolderPin */
export type CreateFolderPinPayload = {
  __typename?: 'CreateFolderPinPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  folder: Folder
}

/** Autogenerated input type of CreateGroup */
export type CreateGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  coverImageKey?: Maybe<Scalars['String']>
  description: Scalars['String']
  isPrivate: Scalars['Boolean']
  name: Scalars['String']
}

/** Autogenerated return type of CreateGroup */
export type CreateGroupPayload = {
  __typename?: 'CreateGroupPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  group: Group
}

/** Autogenerated input type of CreateGroupPin */
export type CreateGroupPinInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  groupId: Scalars['ID']
  noteId: Scalars['ID']
}

/** Autogenerated return type of CreateGroupPin */
export type CreateGroupPinPayload = {
  __typename?: 'CreateGroupPinPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  group: Group
}

/** Autogenerated input type of CreateNote */
export type CreateNoteInput = {
  /** The default author is the current user, but you can set any user as the author on importing notes */
  authorId?: Maybe<Scalars['ID']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  coediting: Scalars['Boolean']
  content: Scalars['String']
  draft?: Maybe<Scalars['Boolean']>
  folderName?: Maybe<Scalars['String']>
  groupIds: Array<Scalars['ID']>
  /** The time when the note is published. If `draft: true` is specified, the param is ignored. */
  publishedAt?: Maybe<Scalars['DateTime']>
  title: Scalars['String']
}

/** Autogenerated return type of CreateNote */
export type CreateNotePayload = {
  __typename?: 'CreateNotePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  note: Note
}

/** Autogenerated input type of CreateNoteTemplate */
export type CreateNoteTemplateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  coediting: Scalars['Boolean']
  content: Scalars['String']
  folderFullName?: Maybe<Scalars['String']>
  groupIds: Array<Scalars['ID']>
  name: Scalars['String']
  title: Scalars['String']
}

/** Autogenerated return type of CreateNoteTemplate */
export type CreateNoteTemplatePayload = {
  __typename?: 'CreateNoteTemplatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  noteTemplate: NoteTemplate
}

/** Autogenerated input type of DeleteAttachment */
export type DeleteAttachmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['ID']
}

/** Autogenerated return type of DeleteAttachment */
export type DeleteAttachmentPayload = {
  __typename?: 'DeleteAttachmentPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated input type of DeleteComment */
export type DeleteCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['ID']
}

/** Autogenerated return type of DeleteComment */
export type DeleteCommentPayload = {
  __typename?: 'DeleteCommentPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated input type of DeleteGroup */
export type DeleteGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['ID']
  mergeToId?: Maybe<Scalars['ID']>
}

/** Autogenerated return type of DeleteGroup */
export type DeleteGroupPayload = {
  __typename?: 'DeleteGroupPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated input type of DeleteNote */
export type DeleteNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['ID']
}

/** Autogenerated return type of DeleteNote */
export type DeleteNotePayload = {
  __typename?: 'DeleteNotePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated input type of DisableSharedEntry */
export type DisableSharedEntryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated return type of DisableSharedEntry */
export type DisableSharedEntryPayload = {
  __typename?: 'DisableSharedEntryPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated input type of DisableUser */
export type DisableUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['ID']
}

/** Autogenerated return type of DisableUser */
export type DisableUserPayload = {
  __typename?: 'DisableUserPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated input type of EnableSharedEntry */
export type EnableSharedEntryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated return type of EnableSharedEntry */
export type EnableSharedEntryPayload = {
  __typename?: 'EnableSharedEntryPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** A section of a feed, which includes notes in a folder */
export type FeedFolderParcel = {
  __typename?: 'FeedFolderParcel'
  date: Scalars['DateTime']
  folder: Folder
  notes: NoteConnection
}

/** A section of a feed, which includes notes in a folder */
export type FeedFolderParcelNotesArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
}

/** The kind to indicate what the feed is */
export enum FeedKind {
  All = 'ALL',
  Group = 'GROUP',
  MyFeed = 'MY_FEED',
}

/** A section of feed, which includes a note */
export type FeedNote = {
  __typename?: 'FeedNote'
  date: Scalars['DateTime']
  note: Note
}

/** A section of feed, which includes one or more notes */
export type FeedSection = FeedFolderParcel | FeedNote | FeedUserParcel

export type FeedSectionSimpleConnection = {
  __typename?: 'FeedSectionSimpleConnection'
  edges: Array<FeedSectionSimpleEdge>
  pageInfo: FeedSectionSimplePageInfo
}

export type FeedSectionSimpleEdge = {
  __typename?: 'FeedSectionSimpleEdge'
  node: FeedSection
}

export type FeedSectionSimplePageInfo = {
  __typename?: 'FeedSectionSimplePageInfo'
  endCursor: Scalars['String']
}

/** A section of feed, which includes notes written by a user */
export type FeedUserParcel = {
  __typename?: 'FeedUserParcel'
  date: Scalars['DateTime']
  notes: NoteConnection
  user: User
}

/** A section of feed, which includes notes written by a user */
export type FeedUserParcelNotesArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
}

export type Folder = Node & {
  __typename?: 'Folder'
  archivedAt?: Maybe<Scalars['DateTime']>
  components: Array<Folder>
  createdAt: Scalars['DateTime']
  folders: FolderConnection
  fullName: Scalars['String']
  id: Scalars['ID']
  lastModifiedAt?: Maybe<Scalars['DateTime']>
  name: Scalars['String']
  newNotePath: Scalars['String']
  notes: NoteConnection
  path: Scalars['String']
  pinnedNotes: NoteConnection
  updatedAt: Scalars['DateTime']
}

export type FolderFoldersArgs = {
  active?: Maybe<Scalars['Boolean']>
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
}

export type FolderNotesArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  onlyCoediting?: Maybe<Scalars['Boolean']>
  orderBy?: Maybe<NoteOrder>
}

export type FolderPinnedNotesArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
}

/** The connection type for Folder. */
export type FolderConnection = {
  __typename?: 'FolderConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<FolderEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Folder>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']
}

/** An edge in a connection. */
export type FolderEdge = {
  __typename?: 'FolderEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']
  /** The item at the end of the edge. */
  node?: Maybe<Folder>
}

export type Group = Node & {
  __typename?: 'Group'
  archivedAt?: Maybe<Scalars['DateTime']>
  canBeDestroyed: Scalars['Boolean']
  canBeManaged: Scalars['Boolean']
  coverImage: GroupCoverImage
  coverImageKey?: Maybe<Scalars['String']>
  createdAt: Scalars['DateTime']
  databaseId: Scalars['Int']
  description: Scalars['String']
  feedSections: FeedSectionSimpleConnection
  feedUpdatedAt?: Maybe<Scalars['DateTime']>
  id: Scalars['ID']
  isArchived: Scalars['Boolean']
  isDefault: Scalars['Boolean']
  isJoined: Scalars['Boolean']
  isPrivate: Scalars['Boolean']
  name: Scalars['String']
  notes: NoteConnection
  path: Scalars['String']
  pinnedNotes: Array<Note>
  todayContributors: UserConnection
  trendNotes: NoteConnection
  updatedAt: Scalars['DateTime']
  users: UserConnection
}

export type GroupCoverImageArgs = {
  density: Scalars['Int']
  size: GroupCoverImageSize
}

export type GroupFeedSectionsArgs = {
  after?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
}

export type GroupNotesArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
}

export type GroupTodayContributorsArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
}

export type GroupTrendNotesArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
}

export type GroupUsersArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
}

/** The connection type for Group. */
export type GroupConnection = {
  __typename?: 'GroupConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GroupEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Group>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']
}

/** Cover image of a group */
export type GroupCoverImage = {
  __typename?: 'GroupCoverImage'
  density: Scalars['Int']
  height: Scalars['Int']
  url: Scalars['String']
  width: Scalars['Int']
}

/** The size class of group cover images */
export enum GroupCoverImageSize {
  Large = 'LARGE',
  Medium = 'MEDIUM',
}

/** An edge in a connection. */
export type GroupEdge = {
  __typename?: 'GroupEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']
  /** The item at the end of the edge. */
  node?: Maybe<Group>
}

/** Autogenerated input type of IgnoreMultiFactorAuthn */
export type IgnoreMultiFactorAuthnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  userId: Scalars['ID']
}

/** Autogenerated return type of IgnoreMultiFactorAuthn */
export type IgnoreMultiFactorAuthnPayload = {
  __typename?: 'IgnoreMultiFactorAuthnPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** A user representation from importable services */
export type ImportableUser = {
  __typename?: 'ImportableUser'
  account: Scalars['String']
  avatarUrl: Scalars['String']
  realName: Scalars['String']
}

/** The connection type for ImportableUser. */
export type ImportableUserConnection = {
  __typename?: 'ImportableUserConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ImportableUserEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ImportableUser>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']
}

/** An edge in a connection. */
export type ImportableUserEdge = {
  __typename?: 'ImportableUserEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']
  /** The item at the end of the edge. */
  node?: Maybe<ImportableUser>
}

/** Message hints that suggest what happens in sending invitations */
export enum InvitationHint {
  AlreadyJoined = 'ALREADY_JOINED',
  Invited = 'INVITED',
  ReEnabled = 'RE_ENABLED',
}

/** Autogenerated input type of Invite */
export type InviteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  email: Scalars['String']
  role?: Maybe<Role>
}

/** Autogenerated return type of Invite */
export type InvitePayload = {
  __typename?: 'InvitePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  email: Scalars['String']
  hint: InvitationHint
  role: Role
}

/** Autogenerated input type of JoinGroup */
export type JoinGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  groupId: Scalars['ID']
  userId: Scalars['ID']
}

/** Autogenerated return type of JoinGroup */
export type JoinGroupPayload = {
  __typename?: 'JoinGroupPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated input type of LeaveGroup */
export type LeaveGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  groupId: Scalars['ID']
  userId: Scalars['ID']
}

/** Autogenerated return type of LeaveGroup */
export type LeaveGroupPayload = {
  __typename?: 'LeaveGroupPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated input type of Like */
export type LikeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  likableId: Scalars['ID']
}

/** Autogenerated return type of Like */
export type LikePayload = {
  __typename?: 'LikePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  likers: UserConnection
}

/** Autogenerated return type of Like */
export type LikePayloadLikersArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
}

/** Autogenerated input type of MarkNotificationsAsRead */
export type MarkNotificationsAsReadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated return type of MarkNotificationsAsRead */
export type MarkNotificationsAsReadPayload = {
  __typename?: 'MarkNotificationsAsReadPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** The top-level mutation type to mutate resources */
export type Mutation = {
  __typename?: 'Mutation'
  /** Archive a folder */
  archiveFolder?: Maybe<ArchiveFolderPayload>
  /** Archive a group */
  archiveGroup?: Maybe<ArchiveGroupPayload>
  /** Close an announcement */
  closeAnnouncement?: Maybe<CloseAnnouncementPayload>
  /** It creates an access token */
  createAccessToken?: Maybe<CreateAccessTokenPayload>
  /** Creates a comment */
  createComment?: Maybe<CreateCommentPayload>
  /** Pin note to a folder */
  createFolderPin?: Maybe<CreateFolderPinPayload>
  /** Create a group */
  createGroup?: Maybe<CreateGroupPayload>
  /** Pin note to a group */
  createGroupPin?: Maybe<CreateGroupPinPayload>
  /** Creates a note */
  createNote?: Maybe<CreateNotePayload>
  /** Create a note template */
  createNoteTemplate?: Maybe<CreateNoteTemplatePayload>
  /** It deletes an attachment that is owned by the current user. */
  deleteAttachment?: Maybe<DeleteAttachmentPayload>
  /** Deletes a comment */
  deleteComment?: Maybe<DeleteCommentPayload>
  /** Delete a group */
  deleteGroup?: Maybe<DeleteGroupPayload>
  /** Deletes a note */
  deleteNote?: Maybe<DeleteNotePayload>
  /** Disable shared entry setting */
  disableSharedEntry?: Maybe<DisableSharedEntryPayload>
  /** Disables a user. The current user must be an *admin* or *owner*. */
  disableUser?: Maybe<DisableUserPayload>
  /** Enable shared entry setting */
  enableSharedEntry?: Maybe<EnableSharedEntryPayload>
  /** Ignore multi factor authn for 1 day. */
  ignoreMultiFactorAuthn?: Maybe<IgnoreMultiFactorAuthnPayload>
  /** Invites a user with their email. Only owners and admins can invite users. */
  invite?: Maybe<InvitePayload>
  /** Join a group */
  joinGroup?: Maybe<JoinGroupPayload>
  /** Leave a group */
  leaveGroup?: Maybe<LeaveGroupPayload>
  /** Like a note or comment */
  like?: Maybe<LikePayload>
  markNotificationsAsRead?: Maybe<MarkNotificationsAsReadPayload>
  /** Remove pinned note from a folder */
  removeFolderPin?: Maybe<RemoveFolderPinPayload>
  /** Remove pinned note from a group */
  removeGroupPin?: Maybe<RemoveGroupPinPayload>
  /** Restore an archived folder */
  restoreFolder?: Maybe<RestoreFolderPayload>
  /** Restore an archived group */
  restoreGroup?: Maybe<RestoreGroupPayload>
  /** It revokes an access token; the secret `token` is available after the access token is revoked. */
  revokeAccessToken?: Maybe<RevokeAccessTokenPayload>
  /** Transfer notes of a group to another */
  transferGroupNotes?: Maybe<TransferGroupNotesPayload>
  /** Unlike a note or comment */
  unlike?: Maybe<UnlikePayload>
  /** It updates attributes of an access token */
  updateAccessToken?: Maybe<UpdateAccessTokenPayload>
  /** Updates a comment */
  updateComment?: Maybe<UpdateCommentPayload>
  /** Update a dashboard */
  updateDashboard?: Maybe<UpdateDashboardPayload>
  /** Update name of a folder */
  updateFolderName?: Maybe<UpdateFolderNamePayload>
  /** Update a group */
  updateGroup?: Maybe<UpdateGroupPayload>
  /** Update a note, trying to merge conflicts */
  updateNote?: Maybe<UpdateNotePayload>
  /** Update the folder associated to a note */
  updateNoteFolder?: Maybe<UpdateNoteFolderPayload>
  /** Update a note template */
  updateNoteTemplate?: Maybe<UpdateNoteTemplatePayload>
  /** Update title of a note */
  updateNoteTitle?: Maybe<UpdateNoteTitlePayload>
  /** Update team setting */
  updateTeamSetting?: Maybe<UpdateTeamSettingPayload>
  /** Upload an attachment as files in markdown contents, avatars, or cover images. */
  uploadAttachment?: Maybe<UploadAttachmentPayload>
  /** Upload an attachment as files in markdown contents, avatars, or cover images. */
  uploadAttachmentWithDataUrl?: Maybe<UploadAttachmentWithDataUrlPayload>
}

/** The top-level mutation type to mutate resources */
export type MutationArchiveFolderArgs = {
  input: ArchiveFolderInput
}

/** The top-level mutation type to mutate resources */
export type MutationArchiveGroupArgs = {
  input: ArchiveGroupInput
}

/** The top-level mutation type to mutate resources */
export type MutationCloseAnnouncementArgs = {
  input: CloseAnnouncementInput
}

/** The top-level mutation type to mutate resources */
export type MutationCreateAccessTokenArgs = {
  input: CreateAccessTokenInput
}

/** The top-level mutation type to mutate resources */
export type MutationCreateCommentArgs = {
  input: CreateCommentInput
}

/** The top-level mutation type to mutate resources */
export type MutationCreateFolderPinArgs = {
  input: CreateFolderPinInput
}

/** The top-level mutation type to mutate resources */
export type MutationCreateGroupArgs = {
  input: CreateGroupInput
}

/** The top-level mutation type to mutate resources */
export type MutationCreateGroupPinArgs = {
  input: CreateGroupPinInput
}

/** The top-level mutation type to mutate resources */
export type MutationCreateNoteArgs = {
  input: CreateNoteInput
}

/** The top-level mutation type to mutate resources */
export type MutationCreateNoteTemplateArgs = {
  input: CreateNoteTemplateInput
}

/** The top-level mutation type to mutate resources */
export type MutationDeleteAttachmentArgs = {
  input: DeleteAttachmentInput
}

/** The top-level mutation type to mutate resources */
export type MutationDeleteCommentArgs = {
  input: DeleteCommentInput
}

/** The top-level mutation type to mutate resources */
export type MutationDeleteGroupArgs = {
  input: DeleteGroupInput
}

/** The top-level mutation type to mutate resources */
export type MutationDeleteNoteArgs = {
  input: DeleteNoteInput
}

/** The top-level mutation type to mutate resources */
export type MutationDisableSharedEntryArgs = {
  input: DisableSharedEntryInput
}

/** The top-level mutation type to mutate resources */
export type MutationDisableUserArgs = {
  input: DisableUserInput
}

/** The top-level mutation type to mutate resources */
export type MutationEnableSharedEntryArgs = {
  input: EnableSharedEntryInput
}

/** The top-level mutation type to mutate resources */
export type MutationIgnoreMultiFactorAuthnArgs = {
  input: IgnoreMultiFactorAuthnInput
}

/** The top-level mutation type to mutate resources */
export type MutationInviteArgs = {
  input: InviteInput
}

/** The top-level mutation type to mutate resources */
export type MutationJoinGroupArgs = {
  input: JoinGroupInput
}

/** The top-level mutation type to mutate resources */
export type MutationLeaveGroupArgs = {
  input: LeaveGroupInput
}

/** The top-level mutation type to mutate resources */
export type MutationLikeArgs = {
  input: LikeInput
}

/** The top-level mutation type to mutate resources */
export type MutationMarkNotificationsAsReadArgs = {
  input: MarkNotificationsAsReadInput
}

/** The top-level mutation type to mutate resources */
export type MutationRemoveFolderPinArgs = {
  input: RemoveFolderPinInput
}

/** The top-level mutation type to mutate resources */
export type MutationRemoveGroupPinArgs = {
  input: RemoveGroupPinInput
}

/** The top-level mutation type to mutate resources */
export type MutationRestoreFolderArgs = {
  input: RestoreFolderInput
}

/** The top-level mutation type to mutate resources */
export type MutationRestoreGroupArgs = {
  input: RestoreGroupInput
}

/** The top-level mutation type to mutate resources */
export type MutationRevokeAccessTokenArgs = {
  input: RevokeAccessTokenInput
}

/** The top-level mutation type to mutate resources */
export type MutationTransferGroupNotesArgs = {
  input: TransferGroupNotesInput
}

/** The top-level mutation type to mutate resources */
export type MutationUnlikeArgs = {
  input: UnlikeInput
}

/** The top-level mutation type to mutate resources */
export type MutationUpdateAccessTokenArgs = {
  input: UpdateAccessTokenInput
}

/** The top-level mutation type to mutate resources */
export type MutationUpdateCommentArgs = {
  input: UpdateCommentInput
}

/** The top-level mutation type to mutate resources */
export type MutationUpdateDashboardArgs = {
  input: UpdateDashboardInput
}

/** The top-level mutation type to mutate resources */
export type MutationUpdateFolderNameArgs = {
  input: UpdateFolderNameInput
}

/** The top-level mutation type to mutate resources */
export type MutationUpdateGroupArgs = {
  input: UpdateGroupInput
}

/** The top-level mutation type to mutate resources */
export type MutationUpdateNoteArgs = {
  input: UpdateNoteInput
}

/** The top-level mutation type to mutate resources */
export type MutationUpdateNoteFolderArgs = {
  input: UpdateNoteFolderInput
}

/** The top-level mutation type to mutate resources */
export type MutationUpdateNoteTemplateArgs = {
  input: UpdateNoteTemplateInput
}

/** The top-level mutation type to mutate resources */
export type MutationUpdateNoteTitleArgs = {
  input: UpdateNoteTitleInput
}

/** The top-level mutation type to mutate resources */
export type MutationUpdateTeamSettingArgs = {
  input: UpdateTeamSettingInput
}

/** The top-level mutation type to mutate resources */
export type MutationUploadAttachmentArgs = {
  input: UploadAttachmentInput
}

/** The top-level mutation type to mutate resources */
export type MutationUploadAttachmentWithDataUrlArgs = {
  input: UploadAttachmentWithDataUrlInput
}

/** An object with an ID. */
export type Node = {
  __typename?: 'Node'
  /** ID of the object. */
  id: Scalars['ID']
}

/** Note (previously called as Blog and Wiki) */
export type Note = Node & {
  __typename?: 'Note'
  author?: Maybe<User>
  canBeDestroyed: Scalars['Boolean']
  canBeUpdated: Scalars['Boolean']
  coediting: Scalars['Boolean']
  comments: CommentConnection
  content: Scalars['String']
  contentHtml: Scalars['String']
  contentSummaryHtml: Scalars['String']
  contentTocHtml: Scalars['String']
  contentUpdatedAt: Scalars['DateTime']
  contributors: UserConnection
  createdAt: Scalars['DateTime']
  databaseId: Scalars['Int']
  editPath: Scalars['String']
  folder?: Maybe<Folder>
  folderName?: Maybe<Scalars['String']>
  groups: Array<Group>
  id: Scalars['ID']
  isLikedByCurrentUser: Scalars['Boolean']
  likers: UserConnection
  path: Scalars['String']
  publishedAt?: Maybe<Scalars['DateTime']>
  relatedNotes: SearchResultConnection
  title: Scalars['String']
  titleHtml: Scalars['String']
  trackbackNotes: NoteConnection
  updatedAt: Scalars['DateTime']
  url: Scalars['String']
}

/** Note (previously called as Blog and Wiki) */
export type NoteCommentsArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
}

/** Note (previously called as Blog and Wiki) */
export type NoteContributorsArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  orderBy?: Maybe<ContributorOrder>
}

/** Note (previously called as Blog and Wiki) */
export type NoteLikersArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
}

/** Note (previously called as Blog and Wiki) */
export type NoteRelatedNotesArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
}

/** Note (previously called as Blog and Wiki) */
export type NoteTrackbackNotesArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
}

/** Browsing history of notes */
export type NoteBrowsingHistory = Node & {
  __typename?: 'NoteBrowsingHistory'
  id: Scalars['ID']
  note?: Maybe<Note>
}

/** The connection type for NoteBrowsingHistory. */
export type NoteBrowsingHistoryConnection = {
  __typename?: 'NoteBrowsingHistoryConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NoteBrowsingHistoryEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<NoteBrowsingHistory>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']
}

/** An edge in a connection. */
export type NoteBrowsingHistoryEdge = {
  __typename?: 'NoteBrowsingHistoryEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']
  /** The item at the end of the edge. */
  node?: Maybe<NoteBrowsingHistory>
}

/** The connection type for Note. */
export type NoteConnection = {
  __typename?: 'NoteConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NoteEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Note>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']
}

/** An edge in a connection. */
export type NoteEdge = {
  __typename?: 'NoteEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']
  /** The item at the end of the edge. */
  node?: Maybe<Note>
}

/** Note input struct, used to updateNote mutation */
export type NoteInput = {
  coediting: Scalars['Boolean']
  content: Scalars['String']
  folderName?: Maybe<Scalars['String']>
  groupIds: Array<Scalars['ID']>
  title: Scalars['String']
}

export type NoteOrder = {
  direction?: Maybe<OrderDirection>
  field?: Maybe<NoteOrderField>
}

/** Properties by which notes can be ordered. */
export enum NoteOrderField {
  ContentUpdatedAt = 'CONTENT_UPDATED_AT',
  PublishedAt = 'PUBLISHED_AT',
  Title = 'TITLE',
}

/** Template of note */
export type NoteTemplate = Node & {
  __typename?: 'NoteTemplate'
  content: Scalars['String']
  createdAt: Scalars['DateTime']
  evaluatedTitle: Scalars['String']
  folderEvaluatedFullName?: Maybe<Scalars['String']>
  folderFullName?: Maybe<Scalars['String']>
  groups: Array<Group>
  id: Scalars['ID']
  name: Scalars['String']
  title: Scalars['String']
  updatedAt: Scalars['DateTime']
}

/** The connection type for NoteTemplate. */
export type NoteTemplateConnection = {
  __typename?: 'NoteTemplateConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NoteTemplateEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<NoteTemplate>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']
}

/** An edge in a connection. */
export type NoteTemplateEdge = {
  __typename?: 'NoteTemplateEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']
  /** The item at the end of the edge. */
  node?: Maybe<NoteTemplate>
}

/** Notifications you get in a Kibela team */
export type Notification = Node & {
  __typename?: 'Notification'
  createdAt: Scalars['DateTime']
  id: Scalars['ID']
  messageHtml: Scalars['String']
  sender: User
  sourcePath: Scalars['String']
  state: NotificationState
  updatedAt: Scalars['DateTime']
}

/** The connection type for Notification. */
export type NotificationConnection = {
  __typename?: 'NotificationConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NotificationEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Notification>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']
}

/** An edge in a connection. */
export type NotificationEdge = {
  __typename?: 'NotificationEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']
  /** The item at the end of the edge. */
  node?: Maybe<Notification>
}

/** The state of notifications */
export enum NotificationState {
  Read = 'READ',
  Unread = 'UNREAD',
}

export enum OrderDirection {
  Asc = 'ASC',
  Desc = 'DESC',
}

/** Kind of the organization */
export enum OrganizationKind {
  Company = 'COMPANY',
  Other = 'OTHER',
  Personal = 'PERSONAL',
  Unknown = 'UNKNOWN',
}

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo'
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>
}

/** The top-level query type to Kibela resources */
export type Query = {
  __typename?: 'Query'
  accessTokens: AccessTokenConnection
  attachmentByPath: Attachment
  budget: Budget
  comment?: Maybe<Comment>
  /** The current user of the session */
  currentUser?: Maybe<User>
  defaultGroup?: Maybe<Group>
  feedSections: FeedSectionSimpleConnection
  folder?: Maybe<Folder>
  folders: FolderConnection
  group: Group
  /** All the groups in the team including private ones */
  groups: GroupConnection
  importableUsers: ImportableUserConnection
  /** Fetches an object given its ID. */
  node?: Maybe<Node>
  /** Fetches a list of objects given a list of IDs. */
  nodes: Array<Maybe<Node>>
  note?: Maybe<Note>
  noteBrowsingHistries: NoteBrowsingHistoryConnection
  noteTemplate?: Maybe<NoteTemplate>
  noteTemplates: NoteTemplateConnection
  notes: NoteConnection
  notifications?: Maybe<NotificationConnection>
  renderMarkdownToHtml: Scalars['String']
  search: SearchResultConnection
  user?: Maybe<User>
  users: UserConnection
}

/** The top-level query type to Kibela resources */
export type QueryAccessTokensArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  revoked?: Maybe<Scalars['Boolean']>
}

/** The top-level query type to Kibela resources */
export type QueryAttachmentByPathArgs = {
  path: Scalars['String']
}

/** The top-level query type to Kibela resources */
export type QueryCommentArgs = {
  id: Scalars['ID']
}

/** The top-level query type to Kibela resources */
export type QueryFeedSectionsArgs = {
  after?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  groupId?: Maybe<Scalars['ID']>
  kind?: Maybe<FeedKind>
}

/** The top-level query type to Kibela resources */
export type QueryFolderArgs = {
  id: Scalars['ID']
}

/** The top-level query type to Kibela resources */
export type QueryFoldersArgs = {
  active?: Maybe<Scalars['Boolean']>
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  parentFolderId?: Maybe<Scalars['ID']>
}

/** The top-level query type to Kibela resources */
export type QueryGroupArgs = {
  id: Scalars['ID']
}

/** The top-level query type to Kibela resources */
export type QueryGroupsArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
}

/** The top-level query type to Kibela resources */
export type QueryImportableUsersArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  encryptedAccessToken: Scalars['String']
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  page: Scalars['Int']
  serviceType: Scalars['String']
  teamName: Scalars['String']
}

/** The top-level query type to Kibela resources */
export type QueryNodeArgs = {
  id: Scalars['ID']
}

/** The top-level query type to Kibela resources */
export type QueryNodesArgs = {
  ids: Array<Scalars['ID']>
}

/** The top-level query type to Kibela resources */
export type QueryNoteArgs = {
  id: Scalars['ID']
}

/** The top-level query type to Kibela resources */
export type QueryNoteBrowsingHistriesArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
}

/** The top-level query type to Kibela resources */
export type QueryNoteTemplateArgs = {
  id: Scalars['ID']
}

/** The top-level query type to Kibela resources */
export type QueryNoteTemplatesArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
}

/** The top-level query type to Kibela resources */
export type QueryNotesArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  folderId?: Maybe<Scalars['ID']>
  last?: Maybe<Scalars['Int']>
  orderBy?: Maybe<NoteOrder>
}

/** The top-level query type to Kibela resources */
export type QueryNotificationsArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  state?: Maybe<NotificationState>
}

/** The top-level query type to Kibela resources */
export type QueryRenderMarkdownToHtmlArgs = {
  content: Scalars['String']
  isMain: Scalars['Boolean']
}

/** The top-level query type to Kibela resources */
export type QuerySearchArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  query: Scalars['String']
}

/** The top-level query type to Kibela resources */
export type QueryUserArgs = {
  id: Scalars['ID']
}

/** The top-level query type to Kibela resources */
export type QueryUsersArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  confirmed?: Maybe<Scalars['Boolean']>
  enabled?: Maybe<Scalars['Boolean']>
  first?: Maybe<Scalars['Int']>
  groupId?: Maybe<Scalars['ID']>
  last?: Maybe<Scalars['Int']>
  query?: Maybe<Scalars['String']>
}

/** Autogenerated input type of RemoveFolderPin */
export type RemoveFolderPinInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  noteId: Scalars['ID']
}

/** Autogenerated return type of RemoveFolderPin */
export type RemoveFolderPinPayload = {
  __typename?: 'RemoveFolderPinPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  folder: Folder
}

/** Autogenerated input type of RemoveGroupPin */
export type RemoveGroupPinInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  groupId: Scalars['ID']
  noteId: Scalars['ID']
}

/** Autogenerated return type of RemoveGroupPin */
export type RemoveGroupPinPayload = {
  __typename?: 'RemoveGroupPinPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  group: Group
}

/** Autogenerated input type of RestoreFolder */
export type RestoreFolderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['ID']
}

/** Autogenerated return type of RestoreFolder */
export type RestoreFolderPayload = {
  __typename?: 'RestoreFolderPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  folder: Folder
}

/** Autogenerated input type of RestoreGroup */
export type RestoreGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  groupId: Scalars['ID']
}

/** Autogenerated return type of RestoreGroup */
export type RestoreGroupPayload = {
  __typename?: 'RestoreGroupPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  group: Group
}

/** Autogenerated input type of RevokeAccessToken */
export type RevokeAccessTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** AccessToken ID */
  id: Scalars['ID']
}

/** Autogenerated return type of RevokeAccessToken */
export type RevokeAccessTokenPayload = {
  __typename?: 'RevokeAccessTokenPayload'
  accessToken: AccessToken
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** A role of a user */
export enum Role {
  Admin = 'ADMIN',
  FullMember = 'FULL_MEMBER',
  Guest = 'GUEST',
  Owner = 'OWNER',
}

export type SearchableDocument = Comment | Note

/** A search result that refers to a document */
export type SearchResult = {
  __typename?: 'SearchResult'
  author: User
  contentSummaryHtml: Scalars['String']
  contentUpdatedAt: Scalars['DateTime']
  /** The original searchable document */
  document: SearchableDocument
  folder?: Maybe<Folder>
  path: Scalars['String']
  title: Scalars['String']
  titleHtml: Scalars['String']
  url: Scalars['String']
}

/** The connection type for SearchResult. */
export type SearchResultConnection = {
  __typename?: 'SearchResultConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SearchResultEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SearchResult>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']
}

/** An edge in a connection. */
export type SearchResultEdge = {
  __typename?: 'SearchResultEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']
  /** The item at the end of the edge. */
  node?: Maybe<SearchResult>
}

/** Autogenerated input type of TransferGroupNotes */
export type TransferGroupNotesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  fromGroupId: Scalars['ID']
  toGroupId: Scalars['ID']
}

/** Autogenerated return type of TransferGroupNotes */
export type TransferGroupNotesPayload = {
  __typename?: 'TransferGroupNotesPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  from: Group
  to: Group
}

/** Autogenerated input type of Unlike */
export type UnlikeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  likableId: Scalars['ID']
}

/** Autogenerated return type of Unlike */
export type UnlikePayload = {
  __typename?: 'UnlikePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  likers: UserConnection
}

/** Autogenerated return type of Unlike */
export type UnlikePayloadLikersArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
}

/** Autogenerated input type of UpdateAccessToken */
export type UpdateAccessTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  description: Scalars['String']
  id: Scalars['ID']
  scopes: Array<AccessTokenScope>
  title: Scalars['String']
}

/** Autogenerated return type of UpdateAccessToken */
export type UpdateAccessTokenPayload = {
  __typename?: 'UpdateAccessTokenPayload'
  accessToken: AccessToken
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated input type of UpdateComment */
export type UpdateCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  content: Scalars['String']
  id: Scalars['ID']
}

/** Autogenerated return type of UpdateComment */
export type UpdateCommentPayload = {
  __typename?: 'UpdateCommentPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  comment: Comment
}

/** Autogenerated input type of UpdateDashboard */
export type UpdateDashboardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  content: Scalars['String']
  groupId: Scalars['ID']
}

/** Autogenerated return type of UpdateDashboard */
export type UpdateDashboardPayload = {
  __typename?: 'UpdateDashboardPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  dashboard: NoteTemplate
}

/** Autogenerated input type of UpdateFolderName */
export type UpdateFolderNameInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['ID']
  name: Scalars['String']
}

/** Autogenerated return type of UpdateFolderName */
export type UpdateFolderNamePayload = {
  __typename?: 'UpdateFolderNamePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  folder: Folder
}

/** Autogenerated input type of UpdateGroup */
export type UpdateGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  coverImageKey?: Maybe<Scalars['String']>
  description?: Maybe<Scalars['String']>
  id: Scalars['ID']
  isPrivate?: Maybe<Scalars['Boolean']>
  name?: Maybe<Scalars['String']>
}

/** Autogenerated return type of UpdateGroup */
export type UpdateGroupPayload = {
  __typename?: 'UpdateGroupPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  group: Group
}

/** Autogenerated input type of UpdateNoteFolder */
export type UpdateNoteFolderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  folderFullName?: Maybe<Scalars['String']>
  noteId: Scalars['ID']
}

/** Autogenerated return type of UpdateNoteFolder */
export type UpdateNoteFolderPayload = {
  __typename?: 'UpdateNoteFolderPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  note: Note
}

/** Autogenerated input type of UpdateNote */
export type UpdateNoteInput = {
  baseNote: NoteInput
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  draft: Scalars['Boolean']
  id: Scalars['ID']
  newNote: NoteInput
}

/** Autogenerated return type of UpdateNote */
export type UpdateNotePayload = {
  __typename?: 'UpdateNotePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  note: Note
}

/** Autogenerated input type of UpdateNoteTemplate */
export type UpdateNoteTemplateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  coediting: Scalars['Boolean']
  content: Scalars['String']
  folderFullName?: Maybe<Scalars['String']>
  groupIds: Array<Scalars['ID']>
  id: Scalars['ID']
  name: Scalars['String']
  title: Scalars['String']
}

/** Autogenerated return type of UpdateNoteTemplate */
export type UpdateNoteTemplatePayload = {
  __typename?: 'UpdateNoteTemplatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  noteTemplate: NoteTemplate
}

/** Autogenerated input type of UpdateNoteTitle */
export type UpdateNoteTitleInput = {
  baseTitle: Scalars['String']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['ID']
  newTitle: Scalars['String']
}

/** Autogenerated return type of UpdateNoteTitle */
export type UpdateNoteTitlePayload = {
  __typename?: 'UpdateNoteTitlePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  note: Note
}

/** Autogenerated input type of UpdateTeamSetting */
export type UpdateTeamSettingInput = {
  city?: Maybe<Scalars['String']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  country?: Maybe<Scalars['String']>
  departmentName?: Maybe<Scalars['String']>
  inChargeUserId?: Maybe<Scalars['ID']>
  organizationKind?: Maybe<OrganizationKind>
  organizationName?: Maybe<Scalars['String']>
  phoneNumber?: Maybe<Scalars['String']>
  postalCode?: Maybe<Scalars['String']>
  state?: Maybe<Scalars['String']>
  streetAddress?: Maybe<Scalars['String']>
}

/** Autogenerated return type of UpdateTeamSetting */
export type UpdateTeamSettingPayload = {
  __typename?: 'UpdateTeamSettingPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated input type of UploadAttachment */
export type UploadAttachmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  data: Scalars['Blob']
  /** It indicates how and where the attachment is used. */
  kind: AttachmentKind
  /** The name of attachment, typically a filename. */
  name: Scalars['String']
}

/** Autogenerated return type of UploadAttachment */
export type UploadAttachmentPayload = {
  __typename?: 'UploadAttachmentPayload'
  attachment: Attachment
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** Autogenerated input type of UploadAttachmentWithDataUrl */
export type UploadAttachmentWithDataUrlInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** The data which encoded in Data URL scheme defined in RFC 2397 */
  dataUrl: Scalars['String']
  /** It indicates how and where the attachment is used. */
  kind: AttachmentKind
  /** The name of attachment, typically a filename. */
  name: Scalars['String']
}

/** Autogenerated return type of UploadAttachmentWithDataUrl */
export type UploadAttachmentWithDataUrlPayload = {
  __typename?: 'UploadAttachmentWithDataUrlPayload'
  attachment: Attachment
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
}

/** A user, which is an individual account of a team */
export type User = Node & {
  __typename?: 'User'
  account?: Maybe<Scalars['String']>
  avatar: UserAvatarImage
  avatarImage: UserAvatarImage
  biography?: Maybe<Scalars['String']>
  cover?: Maybe<UserCoverImage>
  coverImage?: Maybe<UserCoverImage>
  groups?: Maybe<GroupConnection>
  id: Scalars['ID']
  latestNotes: NoteConnection
  locale: Scalars['String']
  path?: Maybe<Scalars['String']>
  popularNotes: NoteConnection
  privateNotes: NoteConnection
  realName?: Maybe<Scalars['String']>
  role: Role
  shortBio?: Maybe<Scalars['String']>
  url?: Maybe<Scalars['String']>
}

/** A user, which is an individual account of a team */
export type UserAvatarArgs = {
  density?: Maybe<Scalars['Int']>
  size?: Maybe<UserAvatarImageSize>
}

/** A user, which is an individual account of a team */
export type UserAvatarImageArgs = {
  density?: Maybe<Scalars['Int']>
  size?: Maybe<UserAvatarImageSize>
}

/** A user, which is an individual account of a team */
export type UserCoverArgs = {
  density?: Maybe<Scalars['Int']>
  size?: Maybe<UserCoverImageSize>
}

/** A user, which is an individual account of a team */
export type UserCoverImageArgs = {
  density?: Maybe<Scalars['Int']>
  size?: Maybe<UserCoverImageSize>
}

/** A user, which is an individual account of a team */
export type UserGroupsArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
}

/** A user, which is an individual account of a team */
export type UserLatestNotesArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
}

/** A user, which is an individual account of a team */
export type UserPopularNotesArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
}

/** A user, which is an individual account of a team */
export type UserPrivateNotesArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
}

/** An avatar image of users */
export type UserAvatarImage = {
  __typename?: 'UserAvatarImage'
  density: Scalars['Int']
  height: Scalars['Int']
  url: Scalars['String']
  width: Scalars['Int']
}

/** The size class of user avatar images */
export enum UserAvatarImageSize {
  Large = 'LARGE',
  Medium = 'MEDIUM',
  Small = 'SMALL',
}

/** The connection type for User. */
export type UserConnection = {
  __typename?: 'UserConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']
}

/** A cover image of users */
export type UserCoverImage = {
  __typename?: 'UserCoverImage'
  density: Scalars['Int']
  height: Scalars['Int']
  key: Scalars['String']
  size: UserCoverImageSize
  url: Scalars['String']
  width: Scalars['Int']
}

/** The size class of user cover images */
export enum UserCoverImageSize {
  Medium = 'MEDIUM',
  Original = 'ORIGINAL',
  Small = 'SMALL',
}

/** An edge in a connection. */
export type UserEdge = {
  __typename?: 'UserEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']
  /** The item at the end of the edge. */
  node?: Maybe<User>
}
